# 1130. Minimum Cost Tree From Leaf Values

## Index

- [Problem](#problem)
  - [Link](#Link)
  - [Description and Examlpe](#description-and-examlpe)
  - [Relation](#relation)
- Solutions
  - [Solution1: DP](#solution1-dp)
  - [Solution2: Greedy by Stack](#solution2-greedy-by-stack)

----

## Problem

### Link

-> [1130. Minimum Cost Tree From Leaf Values][1]

### Description and Examlpe

Given an array `arr` of positive integers, consider all binary trees such that:

- Each node has either 0 or 2 children;
- The values of `arr` correspond to the values of each **leaf** in an in-order traversal of the tree.  (Recall that a node is a leaf if and only if it has 0 children.)
- The value of each non-leaf node is equal to the product of the largest leaf value in its left and right subtree respectively.

Among all possible binary trees considered, return the smallest possible sum of the values of each non-leaf node. It is guaranteed this sum fits into a 32-bit integer.

就是给一组叶子节点(按中序遍历顺序排列), 将它们合并(生成中间节点)从而组成一颗二叉树, 每次合并的代价是左右子树中最大叶子节点的值之积. 求将所有叶子节点合并为一颗二叉树的最小代价.

### Relation

- [Topic: Stack][6]

----

## Solution1: DP

### Idea

首先为 dp 解法正名: 虽然说 dp 不是这道题的最佳解法, 在面试的时候可能会挂掉, 但是 dp 至少比 BF 强多了. N 个叶子节点组成的二叉树的数量难以用通项公式表达(反正我不会...), 但是递推式是显然的. 故求出前 20 项, 用 excel 拟合发现是指数级的, 即 `O(2^N)`.  
![1130.figure1.png][3]  
figure1: N 个叶子节点组成的二叉树的数量 F(N) 的趋势线

相比于指数级, dp 算法 `O(N^3)` 的时间复杂度是可以接受的.

接下来讲思路:

1. 这是一个可以分解为子问题的问题, 同时是一个最优化问题, 因此可以考虑使用 dp 算法.
2. 对于 `dp[0, N-1]` 的子问题 `dp[i, j]`, 我们计算 `dp[i, j]` 的所有拆分方法并从中选出 cost 最小的那种. 即 `dp[i, j] = Min(dp[i, k] + dp[k + 1, j] + max(A[i, k]) * max(A[k + 1, j])) for k in range(i,j)`

### Complexity

- Time: `O(N^3)`
- Space: `O(N^2)`

### Code

```java
class Solution {
    public int mctFromLeafValues(int[] arr) {
        int N = arr.length;
        int[][] max = new int[N][N];
        int[][] dp = new int[N][N];
        for (int i = 0; i < N; i++) {
            max[i][i] = arr[i];
            for (int j = i + 1; j < N; j++) {
                max[i][j] = Math.max(max[i][j-1], arr[j]);
            }
        }
        for (int i = N - 1; i >= 0; i--) {
            for (int j = i + 1; j < N; j++) {
                int mincost = Integer.MAX_VALUE;
                for (int k = i; k < j; k++) {
                    mincost = Math.min(mincost, dp[i][k] + dp[k+1][j] + max[i][k] * max[k+1][j]);
                }
                dp[i][j] = mincost;
            }
        }
        return dp[0][N-1];
    }
}
```

----

## Solution2: Greedy by Stack

### Idea

1. 换一个角度思考这个问题:

    > [lee215][5]:
    >
    > The problem can translated as following:
    >
    > Given an array A, choose two neighbors in the array a and b, we can remove the smaller one min(a,b) and the cost is a * b. What is the minimum cost to remove the whole array until only one left?
    >
    > To remove a number a, it needs a cost a * b, where b >= a. So a has to be removed by a bigger number. We want minimize this cost, so we need to minimize b.
    >
    > b has two candidates, the **first** bigger number on the left, the **first** bigger number on the right. The cost to remove a is a * min(left, right).

    ![1130.figure2.png][4]

    至此, 这变成了一个和 [84. Largest Rectangle in Histogram][2] 类似的题目. 第 84 题是用栈求数组 `A` 中元素 `a` 左右两侧首个 `<a` 的元素的位置, 而本题则是用栈求数组 `A` 中元素 `a` 左右两侧首个 `>a` 的元素的位置. 其实就是修改一下入栈出栈的条件.

2. 这个做法的本质是 greedy algorithm, 从而在 dp 的基础上将时间复杂度又削了一刀.

3. BTW, 如果要求给出这种解法, 那这道题应该是 Hard 难度. 因为该解法和第 84 题的思路一致, 而第 84 题是 Hard.

### Complexity

- Time: `O(N)`
- Space: `O(N)`

### Code

```java
class Solution {
    public int mctFromLeafValues(int[] A) {
        int res = 0, n = A.length;
        // 用栈获取栈顶元素的 NGVL
        Stack<Integer> stack = new Stack<>();
        stack.push(Integer.MAX_VALUE); // sentinel
        for (int right : A) {
            while (stack.peek() <= right) {
                // 消除当前栈顶元素
                int a = stack.pop();
                res += a * Math.min(stack.peek(), right);
            }
            stack.push(right);
        }
        // 处理栈中剩余元素
        while (stack.size() > 2) {
            res += stack.pop() * stack.peek();
        }
        return res;
    }
}
```

note: 可以将出栈条件 `while (stack.peek() <= right) {` 中的 `<=` 换成 `<`. 这两种做法的区别是当 `a (ToS) == right` 时:
Cond|Meaning
:--:|--------------
<=  | 用 `right` 消除 `a`
<   | 将 `right` 压栈, 从而在未来用 `a` 消除 `right` (即 `a` 是 `right` 的 "`left`")

[1]: https://leetcode.com/problems/minimum-cost-tree-from-leaf-values/
[2]: ./84.largest-rectanglein-histogram.md
[3]: ./images/1130.figure1.png
[4]: ./images/1130.figure2.png
[5]: https://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/339959/One-Pass-O(N)-Time-and-Space
[6]: ../topics/stack.md
